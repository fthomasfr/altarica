/*
* generated by Xtext
*/
package fr.onair.dsl.safety.altarica.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import fr.onair.dsl.safety.altarica.services.AltaricaGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class AltaricaParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private AltaricaGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new System_OwnedDeclarationsAssignment(this, this, 0, inst);
			case 1: return new AbstractDeclaration_Alternatives(this, this, 1, inst);
			case 2: return new ConstantDefinition_Group(this, this, 2, inst);
			case 3: return new Constant_NameAssignment(this, this, 3, inst);
			case 4: return new AbstractDefinitionConstant_Alternatives(this, this, 4, inst);
			case 5: return new ExpressionConstant_Group(this, this, 5, inst);
			case 6: return new DomainConstant_Group(this, this, 6, inst);
			case 7: return new Domain_Group(this, this, 7, inst);
			case 8: return new AbstractDomain_Alternatives(this, this, 8, inst);
			case 9: return new Range_Group(this, this, 9, inst);
			case 10: return new Enumeration_Group(this, this, 10, inst);
			case 11: return new PrimitiveType_NameAssignment(this, this, 11, inst);
			case 12: return new Literal_NameAssignment(this, this, 12, inst);
			case 13: return new Node_Group(this, this, 13, inst);
			case 14: return new AbstractSpecification_Alternatives(this, this, 14, inst);
			case 15: return new VariableAttribute_NameAssignment(this, this, 15, inst);
			case 16: return new InitSpecification_Group(this, this, 16, inst);
			case 17: return new InitStatement_Group(this, this, 17, inst);
			case 18: return new ExternalSpecification_Group(this, this, 18, inst);
			case 19: return new ExternalDirective_DirectiveAssignment(this, this, 19, inst);
			case 20: return new FlowSpecification_Group(this, this, 20, inst);
			case 21: return new FlowDeclaration_Group(this, this, 21, inst);
			case 22: return new Flow_NameAssignment(this, this, 22, inst);
			case 23: return new EventSpecification_Group(this, this, 23, inst);
			case 24: return new EventDeclaration_Group(this, this, 24, inst);
			case 25: return new Event_Group(this, this, 25, inst);
			case 26: return new Priority_Group(this, this, 26, inst);
			case 27: return new StateSpecification_Group(this, this, 27, inst);
			case 28: return new StateDeclaration_Group(this, this, 28, inst);
			case 29: return new State_NameAssignment(this, this, 29, inst);
			case 30: return new AbstractTypeRef_Alternatives(this, this, 30, inst);
			case 31: return new DomainRef_ReferenceAssignment(this, this, 31, inst);
			case 32: return new NodeInstanceSpecification_Group(this, this, 32, inst);
			case 33: return new NodeInstanceDeclaration_Group(this, this, 33, inst);
			case 34: return new NodeInstance_NameAssignment(this, this, 34, inst);
			case 35: return new AssertSpecification_Group(this, this, 35, inst);
			case 36: return new Assert_Group(this, this, 36, inst);
			case 37: return new VectorSpecification_Group(this, this, 37, inst);
			case 38: return new Vector_Group(this, this, 38, inst);
			case 39: return new VectorParameter_Group(this, this, 39, inst);
			case 40: return new Cardinality_Alternatives(this, this, 40, inst);
			case 41: return new TransitionSpecification_Group(this, this, 41, inst);
			case 42: return new Transition_Group(this, this, 42, inst);
			case 43: return new Affectation_Group(this, this, 43, inst);
			case 44: return new AbstractExpression_Alternatives(this, this, 44, inst);
			case 45: return new AbstractBooleanExpression_Alternatives(this, this, 45, inst);
			case 46: return new Switch_Group(this, this, 46, inst);
			case 47: return new CaseExpression_Group(this, this, 47, inst);
			case 48: return new IfThenElse_Group(this, this, 48, inst);
			case 49: return new Expression_Group(this, this, 49, inst);
			case 50: return new Minus_Group(this, this, 50, inst);
			case 51: return new Multiplication_Group(this, this, 51, inst);
			case 52: return new Division_Group(this, this, 52, inst);
			case 53: return new BooleanExpression_AndParserRuleCall(this, this, 53, inst);
			case 54: return new And_Group(this, this, 54, inst);
			case 55: return new Or_Group(this, this, 55, inst);
			case 56: return new Equal_Group(this, this, 56, inst);
			case 57: return new NotEqual_Group(this, this, 57, inst);
			case 58: return new StrictLower_Group(this, this, 58, inst);
			case 59: return new Lower_Group(this, this, 59, inst);
			case 60: return new StrictUpper_Group(this, this, 60, inst);
			case 61: return new Upper_Group(this, this, 61, inst);
			case 62: return new Imply_Group(this, this, 62, inst);
			case 63: return new Not_Alternatives(this, this, 63, inst);
			case 64: return new Atom_Alternatives(this, this, 64, inst);
			case 65: return new EventRef_Group(this, this, 65, inst);
			case 66: return new VariableRef_Group(this, this, 66, inst);
			case 67: return new NavigableVariable_Alternatives(this, this, 67, inst);
			case 68: return new NonNavigableVariable_Alternatives(this, this, 68, inst);
			case 69: return new BooleanLiteral_ValueAssignment(this, this, 69, inst);
			case 70: return new StringLiteral_ValueAssignment(this, this, 70, inst);
			case 71: return new IntegerLiteral_ValueAssignment(this, this, 71, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule System ****************
 *
 * System:
 * 	ownedDeclarations+=AbstractDeclaration*;
 *
 **/

// ownedDeclarations+=AbstractDeclaration*
protected class System_OwnedDeclarationsAssignment extends AssignmentToken  {
	
	public System_OwnedDeclarationsAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSystemAccess().getOwnedDeclarationsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDeclaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedDeclarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSystemAccess().getOwnedDeclarationsAbstractDeclarationParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new System_OwnedDeclarationsAssignment(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule System ****************/


/************ begin Rule AbstractDeclaration ****************
 *
 * AbstractDeclaration:
 * 	Domain | ConstantDefinition | Node;
 *
 **/

// Domain | ConstantDefinition | Node
protected class AbstractDeclaration_Alternatives extends AlternativesToken {

	public AbstractDeclaration_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractDeclarationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDeclaration_DomainParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractDeclaration_ConstantDefinitionParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AbstractDeclaration_NodeParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantDefinitionRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDomainRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Domain
protected class AbstractDeclaration_DomainParserRuleCall_0 extends RuleCallToken {
	
	public AbstractDeclaration_DomainParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDeclarationAccess().getDomainParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Domain_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Domain_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ConstantDefinition
protected class AbstractDeclaration_ConstantDefinitionParserRuleCall_1 extends RuleCallToken {
	
	public AbstractDeclaration_ConstantDefinitionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDeclarationAccess().getConstantDefinitionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantDefinitionRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ConstantDefinition_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Node
protected class AbstractDeclaration_NodeParserRuleCall_2 extends RuleCallToken {
	
	public AbstractDeclaration_NodeParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDeclarationAccess().getNodeParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Node_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractDeclaration ****************/


/************ begin Rule ConstantDefinition ****************
 *
 * ConstantDefinition:
 * 	"const" constant=Constant expression=AbstractDefinitionConstant ";";
 *
 **/

// "const" constant=Constant expression=AbstractDefinitionConstant ";"
protected class ConstantDefinition_Group extends GroupToken {
	
	public ConstantDefinition_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConstantDefinition_SemicolonKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantDefinitionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "const"
protected class ConstantDefinition_ConstKeyword_0 extends KeywordToken  {
	
	public ConstantDefinition_ConstKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getConstKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// constant=Constant
protected class ConstantDefinition_ConstantAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinition_ConstantAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getConstantAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Constant_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("constant",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getConstantDefinitionAccess().getConstantConstantParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstantDefinition_ConstKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// expression=AbstractDefinitionConstant
protected class ConstantDefinition_ExpressionAssignment_2 extends AssignmentToken  {
	
	public ConstantDefinition_ExpressionAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getExpressionAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDefinitionConstant_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractDefinitionConstantRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getConstantDefinitionAccess().getExpressionAbstractDefinitionConstantParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstantDefinition_ConstantAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class ConstantDefinition_SemicolonKeyword_3 extends KeywordToken  {
	
	public ConstantDefinition_SemicolonKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getSemicolonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConstantDefinition_ExpressionAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule ConstantDefinition ****************/


/************ begin Rule Constant ****************
 *
 * Constant:
 * 	name=ID;
 *
 **/

// name=ID
protected class Constant_NameAssignment extends AssignmentToken  {
	
	public Constant_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getConstantAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getConstantAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Constant ****************/


/************ begin Rule AbstractDefinitionConstant ****************
 *
 * AbstractDefinitionConstant:
 * 	ExpressionConstant | DomainConstant;
 *
 **/

// ExpressionConstant | DomainConstant
protected class AbstractDefinitionConstant_Alternatives extends AlternativesToken {

	public AbstractDefinitionConstant_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractDefinitionConstantAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDefinitionConstant_ExpressionConstantParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractDefinitionConstant_DomainConstantParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainConstantRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getExpressionConstantRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ExpressionConstant
protected class AbstractDefinitionConstant_ExpressionConstantParserRuleCall_0 extends RuleCallToken {
	
	public AbstractDefinitionConstant_ExpressionConstantParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDefinitionConstantAccess().getExpressionConstantParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExpressionConstant_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionConstantRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ExpressionConstant_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// DomainConstant
protected class AbstractDefinitionConstant_DomainConstantParserRuleCall_1 extends RuleCallToken {
	
	public AbstractDefinitionConstant_DomainConstantParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDefinitionConstantAccess().getDomainConstantParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DomainConstant_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainConstantRule().getType().getClassifier())
			return null;
		if(checkForRecursion(DomainConstant_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractDefinitionConstant ****************/


/************ begin Rule ExpressionConstant ****************
 *
 * ExpressionConstant:
 * 	"=" ownedExpression=Expression;
 *
 **/

// "=" ownedExpression=Expression
protected class ExpressionConstant_Group extends GroupToken {
	
	public ExpressionConstant_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionConstantAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExpressionConstant_OwnedExpressionAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionConstantRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "="
protected class ExpressionConstant_EqualsSignKeyword_0 extends KeywordToken  {
	
	public ExpressionConstant_EqualsSignKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionConstantAccess().getEqualsSignKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedExpression=Expression
protected class ExpressionConstant_OwnedExpressionAssignment_1 extends AssignmentToken  {
	
	public ExpressionConstant_OwnedExpressionAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionConstantAccess().getOwnedExpressionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getExpressionConstantAccess().getOwnedExpressionExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExpressionConstant_EqualsSignKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ExpressionConstant ****************/


/************ begin Rule DomainConstant ****************
 *
 * DomainConstant:
 * 	":" domain=AbstractDomain ("=" ownedExpression=Expression)?;
 *
 **/

// ":" domain=AbstractDomain ("=" ownedExpression=Expression)?
protected class DomainConstant_Group extends GroupToken {
	
	public DomainConstant_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DomainConstant_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DomainConstant_DomainAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainConstantRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ":"
protected class DomainConstant_ColonKeyword_0 extends KeywordToken  {
	
	public DomainConstant_ColonKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getColonKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// domain=AbstractDomain
protected class DomainConstant_DomainAssignment_1 extends AssignmentToken  {
	
	public DomainConstant_DomainAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getDomainAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDomain_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("domain",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("domain");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractDomainRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDomainConstantAccess().getDomainAbstractDomainParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DomainConstant_ColonKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("=" ownedExpression=Expression)?
protected class DomainConstant_Group_2 extends GroupToken {
	
	public DomainConstant_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DomainConstant_OwnedExpressionAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "="
protected class DomainConstant_EqualsSignKeyword_2_0 extends KeywordToken  {
	
	public DomainConstant_EqualsSignKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getEqualsSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DomainConstant_DomainAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ownedExpression=Expression
protected class DomainConstant_OwnedExpressionAssignment_2_1 extends AssignmentToken  {
	
	public DomainConstant_OwnedExpressionAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDomainConstantAccess().getOwnedExpressionAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpression",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDomainConstantAccess().getOwnedExpressionExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DomainConstant_EqualsSignKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule DomainConstant ****************/


/************ begin Rule Domain ****************
 *
 * Domain:
 * 	"domain" name=ID "=" domain=AbstractDomain ";";
 *
 **/

// "domain" name=ID "=" domain=AbstractDomain ";"
protected class Domain_Group extends GroupToken {
	
	public Domain_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDomainAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Domain_SemicolonKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "domain"
protected class Domain_DomainKeyword_0 extends KeywordToken  {
	
	public Domain_DomainKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDomainAccess().getDomainKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// name=ID
protected class Domain_NameAssignment_1 extends AssignmentToken  {
	
	public Domain_NameAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDomainAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Domain_DomainKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getDomainAccess().getNameIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getDomainAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class Domain_EqualsSignKeyword_2 extends KeywordToken  {
	
	public Domain_EqualsSignKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDomainAccess().getEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Domain_NameAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// domain=AbstractDomain
protected class Domain_DomainAssignment_3 extends AssignmentToken  {
	
	public Domain_DomainAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDomainAccess().getDomainAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDomain_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("domain",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("domain");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractDomainRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDomainAccess().getDomainAbstractDomainParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Domain_EqualsSignKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class Domain_SemicolonKeyword_4 extends KeywordToken  {
	
	public Domain_SemicolonKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDomainAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Domain_DomainAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule Domain ****************/


/************ begin Rule AbstractDomain ****************
 *
 * AbstractDomain:
 * 	PrimitiveType | Range | Enumeration;
 *
 **/

// PrimitiveType | Range | Enumeration
protected class AbstractDomain_Alternatives extends AlternativesToken {

	public AbstractDomain_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractDomainAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDomain_PrimitiveTypeParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractDomain_RangeParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AbstractDomain_EnumerationParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumerationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPrimitiveTypeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRangeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// PrimitiveType
protected class AbstractDomain_PrimitiveTypeParserRuleCall_0 extends RuleCallToken {
	
	public AbstractDomain_PrimitiveTypeParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDomainAccess().getPrimitiveTypeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimitiveType_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPrimitiveTypeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(PrimitiveType_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Range
protected class AbstractDomain_RangeParserRuleCall_1 extends RuleCallToken {
	
	public AbstractDomain_RangeParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDomainAccess().getRangeParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Range_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRangeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Range_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Enumeration
protected class AbstractDomain_EnumerationParserRuleCall_2 extends RuleCallToken {
	
	public AbstractDomain_EnumerationParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractDomainAccess().getEnumerationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Enumeration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumerationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Enumeration_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractDomain ****************/


/************ begin Rule Range ****************
 *
 * Range:
 * 	"[" lower=Atom "," upper=Atom "]";
 *
 **/

// "[" lower=Atom "," upper=Atom "]"
protected class Range_Group extends GroupToken {
	
	public Range_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRangeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Range_RightSquareBracketKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRangeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "["
protected class Range_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public Range_LeftSquareBracketKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeAccess().getLeftSquareBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// lower=Atom
protected class Range_LowerAssignment_1 extends AssignmentToken  {
	
	public Range_LowerAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeAccess().getLowerAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("lower",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("lower");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRangeAccess().getLowerAtomParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Range_LeftSquareBracketKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ","
protected class Range_CommaKeyword_2 extends KeywordToken  {
	
	public Range_CommaKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeAccess().getCommaKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Range_LowerAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// upper=Atom
protected class Range_UpperAssignment_3 extends AssignmentToken  {
	
	public Range_UpperAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeAccess().getUpperAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("upper",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("upper");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRangeAccess().getUpperAtomParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Range_CommaKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class Range_RightSquareBracketKeyword_4 extends KeywordToken  {
	
	public Range_RightSquareBracketKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeAccess().getRightSquareBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Range_UpperAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule Range ****************/


/************ begin Rule Enumeration ****************
 *
 * Enumeration:
 * 	"{" ownedLiterals+=Literal ("," ownedLiterals+=Literal)* "}";
 *
 **/

// "{" ownedLiterals+=Literal ("," ownedLiterals+=Literal)* "}"
protected class Enumeration_Group extends GroupToken {
	
	public Enumeration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Enumeration_RightCurlyBracketKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumerationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "{"
protected class Enumeration_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public Enumeration_LeftCurlyBracketKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedLiterals+=Literal
protected class Enumeration_OwnedLiteralsAssignment_1 extends AssignmentToken  {
	
	public Enumeration_OwnedLiteralsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getOwnedLiteralsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Literal_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedLiterals",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedLiterals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEnumerationAccess().getOwnedLiteralsLiteralParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Enumeration_LeftCurlyBracketKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," ownedLiterals+=Literal)*
protected class Enumeration_Group_2 extends GroupToken {
	
	public Enumeration_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Enumeration_OwnedLiteralsAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class Enumeration_CommaKeyword_2_0 extends KeywordToken  {
	
	public Enumeration_CommaKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Enumeration_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Enumeration_OwnedLiteralsAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedLiterals+=Literal
protected class Enumeration_OwnedLiteralsAssignment_2_1 extends AssignmentToken  {
	
	public Enumeration_OwnedLiteralsAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getOwnedLiteralsAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Literal_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedLiterals",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedLiterals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEnumerationAccess().getOwnedLiteralsLiteralParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Enumeration_CommaKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class Enumeration_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Enumeration_RightCurlyBracketKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumerationAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Enumeration_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Enumeration_OwnedLiteralsAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule Enumeration ****************/


/************ begin Rule PrimitiveType ****************
 *
 * PrimitiveType:
 * 	name=PrimitiveTypeKind;
 *
 **/

// name=PrimitiveTypeKind
protected class PrimitiveType_NameAssignment extends AssignmentToken  {
	
	public PrimitiveType_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPrimitiveTypeRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getPrimitiveTypeAccess().getNamePrimitiveTypeKindEnumRuleCall_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getPrimitiveTypeAccess().getNamePrimitiveTypeKindEnumRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule PrimitiveType ****************/


/************ begin Rule Literal ****************
 *
 * Literal:
 * 	name=ID;
 *
 **/

// name=ID
protected class Literal_NameAssignment extends AssignmentToken  {
	
	public Literal_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getLiteralAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getLiteralAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Literal ****************/


/************ begin Rule Node ****************
 *
 * Node:
 * 	"node" isMain?="Main"? name=ID ownedSpecifications+=AbstractSpecification* "edon";
 *
 **/

// "node" isMain?="Main"? name=ID ownedSpecifications+=AbstractSpecification* "edon"
protected class Node_Group extends GroupToken {
	
	public Node_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_EdonKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "node"
protected class Node_NodeKeyword_0 extends KeywordToken  {
	
	public Node_NodeKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getNodeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// isMain?="Main"?
protected class Node_IsMainAssignment_1 extends AssignmentToken  {
	
	public Node_IsMainAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getIsMainAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_NodeKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("isMain",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("isMain");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getNodeAccess().getIsMainMainKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// name=ID
protected class Node_NameAssignment_2 extends AssignmentToken  {
	
	public Node_NameAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_IsMainAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Node_NodeKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_2_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ownedSpecifications+=AbstractSpecification*
protected class Node_OwnedSpecificationsAssignment_3 extends AssignmentToken  {
	
	public Node_OwnedSpecificationsAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getOwnedSpecificationsAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedSpecifications",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedSpecifications");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNodeAccess().getOwnedSpecificationsAbstractSpecificationParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_OwnedSpecificationsAssignment_3(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Node_NameAssignment_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "edon"
protected class Node_EdonKeyword_4 extends KeywordToken  {
	
	public Node_EdonKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getEdonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_OwnedSpecificationsAssignment_3(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Node_NameAssignment_2(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule Node ****************/


/************ begin Rule AbstractSpecification ****************
 *
 * AbstractSpecification:
 * 	FlowSpecification | StateSpecification | EventSpecification | NodeInstanceSpecification | AssertSpecification |
 * 	VectorSpecification | TransitionSpecification | InitSpecification | ExternalSpecification;
 *
 **/

// FlowSpecification | StateSpecification | EventSpecification | NodeInstanceSpecification | AssertSpecification |
// VectorSpecification | TransitionSpecification | InitSpecification | ExternalSpecification
protected class AbstractSpecification_Alternatives extends AlternativesToken {

	public AbstractSpecification_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractSpecification_FlowSpecificationParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractSpecification_StateSpecificationParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AbstractSpecification_EventSpecificationParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new AbstractSpecification_NodeInstanceSpecificationParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new AbstractSpecification_AssertSpecificationParserRuleCall_4(lastRuleCallOrigin, this, 4, inst);
			case 5: return new AbstractSpecification_VectorSpecificationParserRuleCall_5(lastRuleCallOrigin, this, 5, inst);
			case 6: return new AbstractSpecification_TransitionSpecificationParserRuleCall_6(lastRuleCallOrigin, this, 6, inst);
			case 7: return new AbstractSpecification_InitSpecificationParserRuleCall_7(lastRuleCallOrigin, this, 7, inst);
			case 8: return new AbstractSpecification_ExternalSpecificationParserRuleCall_8(lastRuleCallOrigin, this, 8, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssertSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEventSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getExternalSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFlowSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getInitSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNodeInstanceSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStateSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTransitionSpecificationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVectorSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// FlowSpecification
protected class AbstractSpecification_FlowSpecificationParserRuleCall_0 extends RuleCallToken {
	
	public AbstractSpecification_FlowSpecificationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getFlowSpecificationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFlowSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(FlowSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// StateSpecification
protected class AbstractSpecification_StateSpecificationParserRuleCall_1 extends RuleCallToken {
	
	public AbstractSpecification_StateSpecificationParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getStateSpecificationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStateSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StateSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// EventSpecification
protected class AbstractSpecification_EventSpecificationParserRuleCall_2 extends RuleCallToken {
	
	public AbstractSpecification_EventSpecificationParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getEventSpecificationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(EventSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// NodeInstanceSpecification
protected class AbstractSpecification_NodeInstanceSpecificationParserRuleCall_3 extends RuleCallToken {
	
	public AbstractSpecification_NodeInstanceSpecificationParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getNodeInstanceSpecificationParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeInstanceSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(NodeInstanceSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// AssertSpecification
protected class AbstractSpecification_AssertSpecificationParserRuleCall_4 extends RuleCallToken {
	
	public AbstractSpecification_AssertSpecificationParserRuleCall_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getAssertSpecificationParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AssertSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssertSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(AssertSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// VectorSpecification
protected class AbstractSpecification_VectorSpecificationParserRuleCall_5 extends RuleCallToken {
	
	public AbstractSpecification_VectorSpecificationParserRuleCall_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getVectorSpecificationParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVectorSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(VectorSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// TransitionSpecification
protected class AbstractSpecification_TransitionSpecificationParserRuleCall_6 extends RuleCallToken {
	
	public AbstractSpecification_TransitionSpecificationParserRuleCall_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getTransitionSpecificationParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TransitionSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getTransitionSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(TransitionSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// InitSpecification
protected class AbstractSpecification_InitSpecificationParserRuleCall_7 extends RuleCallToken {
	
	public AbstractSpecification_InitSpecificationParserRuleCall_7(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getInitSpecificationParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new InitSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getInitSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(InitSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ExternalSpecification
protected class AbstractSpecification_ExternalSpecificationParserRuleCall_8 extends RuleCallToken {
	
	public AbstractSpecification_ExternalSpecificationParserRuleCall_8(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractSpecificationAccess().getExternalSpecificationParserRuleCall_8();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalSpecificationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ExternalSpecification_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractSpecification ****************/


/************ begin Rule VariableAttribute ****************
 *
 * VariableAttribute:
 * 	name=ID;
 *
 **/

// name=ID
protected class VariableAttribute_NameAssignment extends AssignmentToken  {
	
	public VariableAttribute_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAttributeAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableAttributeRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getVariableAttributeAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getVariableAttributeAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule VariableAttribute ****************/


/************ begin Rule InitSpecification ****************
 *
 * InitSpecification:
 * 	"init" ownedInitStatements+=InitStatement*;
 *
 **/

// "init" ownedInitStatements+=InitStatement*
protected class InitSpecification_Group extends GroupToken {
	
	public InitSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInitSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new InitSpecification_OwnedInitStatementsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new InitSpecification_InitKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getInitSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "init"
protected class InitSpecification_InitKeyword_0 extends KeywordToken  {
	
	public InitSpecification_InitKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInitSpecificationAccess().getInitKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedInitStatements+=InitStatement*
protected class InitSpecification_OwnedInitStatementsAssignment_1 extends AssignmentToken  {
	
	public InitSpecification_OwnedInitStatementsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInitSpecificationAccess().getOwnedInitStatementsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new InitStatement_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedInitStatements",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedInitStatements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInitStatementRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getInitSpecificationAccess().getOwnedInitStatementsInitStatementParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InitSpecification_OwnedInitStatementsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new InitSpecification_InitKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule InitSpecification ****************/


/************ begin Rule InitStatement ****************
 *
 * InitStatement:
 * 	affectation=Affectation ";";
 *
 **/

// affectation=Affectation ";"
protected class InitStatement_Group extends GroupToken {
	
	public InitStatement_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInitStatementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new InitStatement_SemicolonKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getInitStatementRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// affectation=Affectation
protected class InitStatement_AffectationAssignment_0 extends AssignmentToken  {
	
	public InitStatement_AffectationAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInitStatementAccess().getAffectationAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Affectation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("affectation",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("affectation");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAffectationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getInitStatementAccess().getAffectationAffectationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ";"
protected class InitStatement_SemicolonKeyword_1 extends KeywordToken  {
	
	public InitStatement_SemicolonKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInitStatementAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new InitStatement_AffectationAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule InitStatement ****************/


/************ begin Rule ExternalSpecification ****************
 *
 * ExternalSpecification:
 * 	"extern" ownedDirectives+=ExternalDirective*;
 *
 **/

// "extern" ownedDirectives+=ExternalDirective*
protected class ExternalSpecification_Group extends GroupToken {
	
	public ExternalSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExternalSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalSpecification_OwnedDirectivesAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ExternalSpecification_ExternKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "extern"
protected class ExternalSpecification_ExternKeyword_0 extends KeywordToken  {
	
	public ExternalSpecification_ExternKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExternalSpecificationAccess().getExternKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedDirectives+=ExternalDirective*
protected class ExternalSpecification_OwnedDirectivesAssignment_1 extends AssignmentToken  {
	
	public ExternalSpecification_OwnedDirectivesAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExternalSpecificationAccess().getOwnedDirectivesAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalDirective_DirectiveAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedDirectives",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedDirectives");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExternalDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getExternalSpecificationAccess().getOwnedDirectivesExternalDirectiveParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExternalSpecification_OwnedDirectivesAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new ExternalSpecification_ExternKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ExternalSpecification ****************/


/************ begin Rule ExternalDirective ****************
 *
 * ExternalDirective:
 * 	directive=SL_COMMENT;
 *
 **/

// directive=SL_COMMENT
protected class ExternalDirective_DirectiveAssignment extends AssignmentToken  {
	
	public ExternalDirective_DirectiveAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExternalDirectiveAccess().getDirectiveAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalDirectiveRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("directive",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("directive");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getExternalDirectiveAccess().getDirectiveSL_COMMENTTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getExternalDirectiveAccess().getDirectiveSL_COMMENTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule ExternalDirective ****************/


/************ begin Rule FlowSpecification ****************
 *
 * //terminal Directive returns ecore::EString : "/ *" -> ";";
 * FlowSpecification:
 * 	"flow" ownedDeclarations+=FlowDeclaration*;
 *
 **/

// "flow" ownedDeclarations+=FlowDeclaration*
protected class FlowSpecification_Group extends GroupToken {
	
	public FlowSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFlowSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowSpecification_OwnedDeclarationsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FlowSpecification_FlowKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFlowSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "flow"
protected class FlowSpecification_FlowKeyword_0 extends KeywordToken  {
	
	public FlowSpecification_FlowKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowSpecificationAccess().getFlowKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedDeclarations+=FlowDeclaration*
protected class FlowSpecification_OwnedDeclarationsAssignment_1 extends AssignmentToken  {
	
	public FlowSpecification_OwnedDeclarationsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowSpecificationAccess().getOwnedDeclarationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedDeclarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFlowDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFlowSpecificationAccess().getOwnedDeclarationsFlowDeclarationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FlowSpecification_OwnedDeclarationsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new FlowSpecification_FlowKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FlowSpecification ****************/


/************ begin Rule FlowDeclaration ****************
 *
 * FlowDeclaration:
 * 	ownedFlows+=Flow ("," ownedFlows+=Flow)* ":" domain=AbstractTypeRef (":" kind=FlowKind)? (":"
 * 	attribute=VariableAttribute)? ";";
 *
 **/

// ownedFlows+=Flow ("," ownedFlows+=Flow)* ":" domain=AbstractTypeRef (":" kind=FlowKind)? (":"
// attribute=VariableAttribute)? ";"
protected class FlowDeclaration_Group extends GroupToken {
	
	public FlowDeclaration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_SemicolonKeyword_6(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFlowDeclarationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedFlows+=Flow
protected class FlowDeclaration_OwnedFlowsAssignment_0 extends AssignmentToken  {
	
	public FlowDeclaration_OwnedFlowsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getOwnedFlowsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Flow_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedFlows",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedFlows");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFlowRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFlowDeclarationAccess().getOwnedFlowsFlowParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("," ownedFlows+=Flow)*
protected class FlowDeclaration_Group_1 extends GroupToken {
	
	public FlowDeclaration_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_OwnedFlowsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class FlowDeclaration_CommaKeyword_1_0 extends KeywordToken  {
	
	public FlowDeclaration_CommaKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FlowDeclaration_OwnedFlowsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedFlows+=Flow
protected class FlowDeclaration_OwnedFlowsAssignment_1_1 extends AssignmentToken  {
	
	public FlowDeclaration_OwnedFlowsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getOwnedFlowsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Flow_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedFlows",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedFlows");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFlowRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFlowDeclarationAccess().getOwnedFlowsFlowParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FlowDeclaration_CommaKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":"
protected class FlowDeclaration_ColonKeyword_2 extends KeywordToken  {
	
	public FlowDeclaration_ColonKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FlowDeclaration_OwnedFlowsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// domain=AbstractTypeRef
protected class FlowDeclaration_DomainAssignment_3 extends AssignmentToken  {
	
	public FlowDeclaration_DomainAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getDomainAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractTypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("domain",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("domain");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFlowDeclarationAccess().getDomainAbstractTypeRefParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FlowDeclaration_ColonKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (":" kind=FlowKind)?
protected class FlowDeclaration_Group_4 extends GroupToken {
	
	public FlowDeclaration_Group_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_KindAssignment_4_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ":"
protected class FlowDeclaration_ColonKeyword_4_0 extends KeywordToken  {
	
	public FlowDeclaration_ColonKeyword_4_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getColonKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_DomainAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// kind=FlowKind
protected class FlowDeclaration_KindAssignment_4_1 extends AssignmentToken  {
	
	public FlowDeclaration_KindAssignment_4_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getKindAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_ColonKeyword_4_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("kind",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("kind");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getFlowDeclarationAccess().getKindFlowKindEnumRuleCall_4_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getFlowDeclarationAccess().getKindFlowKindEnumRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// (":" attribute=VariableAttribute)?
protected class FlowDeclaration_Group_5 extends GroupToken {
	
	public FlowDeclaration_Group_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_AttributeAssignment_5_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ":"
protected class FlowDeclaration_ColonKeyword_5_0 extends KeywordToken  {
	
	public FlowDeclaration_ColonKeyword_5_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getColonKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_Group_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FlowDeclaration_DomainAssignment_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// attribute=VariableAttribute
protected class FlowDeclaration_AttributeAssignment_5_1 extends AssignmentToken  {
	
	public FlowDeclaration_AttributeAssignment_5_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getAttributeAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableAttribute_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attribute",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attribute");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFlowDeclarationAccess().getAttributeVariableAttributeParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FlowDeclaration_ColonKeyword_5_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class FlowDeclaration_SemicolonKeyword_6 extends KeywordToken  {
	
	public FlowDeclaration_SemicolonKeyword_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFlowDeclarationAccess().getSemicolonKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FlowDeclaration_Group_5(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FlowDeclaration_Group_4(lastRuleCallOrigin, this, 1, inst);
			case 2: return new FlowDeclaration_DomainAssignment_3(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

}


/************ end Rule FlowDeclaration ****************/


/************ begin Rule Flow ****************
 *
 * Flow:
 * 	name=ID;
 *
 **/

// name=ID
protected class Flow_NameAssignment extends AssignmentToken  {
	
	public Flow_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFlowAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFlowRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFlowAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFlowAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Flow ****************/


/************ begin Rule EventSpecification ****************
 *
 * EventSpecification:
 * 	"event" ownedEventDeclarations+=EventDeclaration*;
 *
 **/

// "event" ownedEventDeclarations+=EventDeclaration*
protected class EventSpecification_Group extends GroupToken {
	
	public EventSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventSpecification_OwnedEventDeclarationsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventSpecification_EventKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "event"
protected class EventSpecification_EventKeyword_0 extends KeywordToken  {
	
	public EventSpecification_EventKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventSpecificationAccess().getEventKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedEventDeclarations+=EventDeclaration*
protected class EventSpecification_OwnedEventDeclarationsAssignment_1 extends AssignmentToken  {
	
	public EventSpecification_OwnedEventDeclarationsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventSpecificationAccess().getOwnedEventDeclarationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedEventDeclarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedEventDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEventSpecificationAccess().getOwnedEventDeclarationsEventDeclarationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EventSpecification_OwnedEventDeclarationsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new EventSpecification_EventKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule EventSpecification ****************/


/************ begin Rule EventDeclaration ****************
 *
 * EventDeclaration:
 * 	ownedEvents+=Event ("," ownedEvents+=Event)* (":" attribute=VariableAttribute)? ";";
 *
 **/

// ownedEvents+=Event ("," ownedEvents+=Event)* (":" attribute=VariableAttribute)? ";"
protected class EventDeclaration_Group extends GroupToken {
	
	public EventDeclaration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_SemicolonKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventDeclarationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedEvents+=Event
protected class EventDeclaration_OwnedEventsAssignment_0 extends AssignmentToken  {
	
	public EventDeclaration_OwnedEventsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getOwnedEventsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedEvents",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedEvents");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEventDeclarationAccess().getOwnedEventsEventParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("," ownedEvents+=Event)*
protected class EventDeclaration_Group_1 extends GroupToken {
	
	public EventDeclaration_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_OwnedEventsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class EventDeclaration_CommaKeyword_1_0 extends KeywordToken  {
	
	public EventDeclaration_CommaKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventDeclaration_OwnedEventsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedEvents+=Event
protected class EventDeclaration_OwnedEventsAssignment_1_1 extends AssignmentToken  {
	
	public EventDeclaration_OwnedEventsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getOwnedEventsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedEvents",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedEvents");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEventDeclarationAccess().getOwnedEventsEventParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EventDeclaration_CommaKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// (":" attribute=VariableAttribute)?
protected class EventDeclaration_Group_2 extends GroupToken {
	
	public EventDeclaration_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_AttributeAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ":"
protected class EventDeclaration_ColonKeyword_2_0 extends KeywordToken  {
	
	public EventDeclaration_ColonKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getColonKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventDeclaration_OwnedEventsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// attribute=VariableAttribute
protected class EventDeclaration_AttributeAssignment_2_1 extends AssignmentToken  {
	
	public EventDeclaration_AttributeAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getAttributeAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableAttribute_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attribute",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attribute");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEventDeclarationAccess().getAttributeVariableAttributeParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EventDeclaration_ColonKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class EventDeclaration_SemicolonKeyword_3 extends KeywordToken  {
	
	public EventDeclaration_SemicolonKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventDeclarationAccess().getSemicolonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventDeclaration_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventDeclaration_Group_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new EventDeclaration_OwnedEventsAssignment_0(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

}


/************ end Rule EventDeclaration ****************/


/************ begin Rule Event ****************
 *
 * Event:
 * 	name=ID ("[" ownedPriority=Priority "]")?;
 *
 **/

// name=ID ("[" ownedPriority=Priority "]")?
protected class Event_Group extends GroupToken {
	
	public Event_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Event_NameAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// name=ID
protected class Event_NameAssignment_0 extends AssignmentToken  {
	
	public Event_NameAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getEventAccess().getNameIDTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getEventAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("[" ownedPriority=Priority "]")?
protected class Event_Group_1 extends GroupToken {
	
	public Event_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_RightSquareBracketKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "["
protected class Event_LeftSquareBracketKeyword_1_0 extends KeywordToken  {
	
	public Event_LeftSquareBracketKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventAccess().getLeftSquareBracketKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_NameAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ownedPriority=Priority
protected class Event_OwnedPriorityAssignment_1_1 extends AssignmentToken  {
	
	public Event_OwnedPriorityAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventAccess().getOwnedPriorityAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Priority_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedPriority",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedPriority");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPriorityRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEventAccess().getOwnedPriorityPriorityParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Event_LeftSquareBracketKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class Event_RightSquareBracketKeyword_1_2 extends KeywordToken  {
	
	public Event_RightSquareBracketKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventAccess().getRightSquareBracketKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_OwnedPriorityAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule Event ****************/


/************ begin Rule Priority ****************
 *
 * Priority:
 * 	("!" | "priority") ownedExpression=AbstractExpression;
 *
 **/

// ("!" | "priority") ownedExpression=AbstractExpression
protected class Priority_Group extends GroupToken {
	
	public Priority_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPriorityAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Priority_OwnedExpressionAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPriorityRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "!" | "priority"
protected class Priority_Alternatives_0 extends AlternativesToken {

	public Priority_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPriorityAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Priority_ExclamationMarkKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "!"
protected class Priority_ExclamationMarkKeyword_0_0 extends KeywordToken  {
	
	public Priority_ExclamationMarkKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPriorityAccess().getExclamationMarkKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// ownedExpression=AbstractExpression
protected class Priority_OwnedExpressionAssignment_1 extends AssignmentToken  {
	
	public Priority_OwnedExpressionAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPriorityAccess().getOwnedExpressionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPriorityAccess().getOwnedExpressionAbstractExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Priority_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Priority ****************/


/************ begin Rule StateSpecification ****************
 *
 * StateSpecification:
 * 	"state" ownedStateDeclarations+=StateDeclaration*;
 *
 **/

// "state" ownedStateDeclarations+=StateDeclaration*
protected class StateSpecification_Group extends GroupToken {
	
	public StateSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateSpecification_OwnedStateDeclarationsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StateSpecification_StateKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStateSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "state"
protected class StateSpecification_StateKeyword_0 extends KeywordToken  {
	
	public StateSpecification_StateKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateSpecificationAccess().getStateKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedStateDeclarations+=StateDeclaration*
protected class StateSpecification_OwnedStateDeclarationsAssignment_1 extends AssignmentToken  {
	
	public StateSpecification_OwnedStateDeclarationsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateSpecificationAccess().getOwnedStateDeclarationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedStateDeclarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedStateDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStateSpecificationAccess().getOwnedStateDeclarationsStateDeclarationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateSpecification_OwnedStateDeclarationsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new StateSpecification_StateKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule StateSpecification ****************/


/************ begin Rule StateDeclaration ****************
 *
 * StateDeclaration:
 * 	ownedStates+=State ("," ownedStates+=State)* ":" domain=AbstractTypeRef (":" attribute=VariableAttribute)? ";";
 *
 **/

// ownedStates+=State ("," ownedStates+=State)* ":" domain=AbstractTypeRef (":" attribute=VariableAttribute)? ";"
protected class StateDeclaration_Group extends GroupToken {
	
	public StateDeclaration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_SemicolonKeyword_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStateDeclarationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedStates+=State
protected class StateDeclaration_OwnedStatesAssignment_0 extends AssignmentToken  {
	
	public StateDeclaration_OwnedStatesAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getOwnedStatesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new State_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedStates",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedStates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStateDeclarationAccess().getOwnedStatesStateParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("," ownedStates+=State)*
protected class StateDeclaration_Group_1 extends GroupToken {
	
	public StateDeclaration_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_OwnedStatesAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class StateDeclaration_CommaKeyword_1_0 extends KeywordToken  {
	
	public StateDeclaration_CommaKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StateDeclaration_OwnedStatesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedStates+=State
protected class StateDeclaration_OwnedStatesAssignment_1_1 extends AssignmentToken  {
	
	public StateDeclaration_OwnedStatesAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getOwnedStatesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new State_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedStates",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedStates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStateDeclarationAccess().getOwnedStatesStateParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateDeclaration_CommaKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":"
protected class StateDeclaration_ColonKeyword_2 extends KeywordToken  {
	
	public StateDeclaration_ColonKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StateDeclaration_OwnedStatesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// domain=AbstractTypeRef
protected class StateDeclaration_DomainAssignment_3 extends AssignmentToken  {
	
	public StateDeclaration_DomainAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getDomainAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractTypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("domain",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("domain");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStateDeclarationAccess().getDomainAbstractTypeRefParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateDeclaration_ColonKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (":" attribute=VariableAttribute)?
protected class StateDeclaration_Group_4 extends GroupToken {
	
	public StateDeclaration_Group_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_AttributeAssignment_4_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ":"
protected class StateDeclaration_ColonKeyword_4_0 extends KeywordToken  {
	
	public StateDeclaration_ColonKeyword_4_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getColonKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_DomainAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// attribute=VariableAttribute
protected class StateDeclaration_AttributeAssignment_4_1 extends AssignmentToken  {
	
	public StateDeclaration_AttributeAssignment_4_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getAttributeAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableAttribute_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attribute",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attribute");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStateDeclarationAccess().getAttributeVariableAttributeParserRuleCall_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateDeclaration_ColonKeyword_4_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class StateDeclaration_SemicolonKeyword_5 extends KeywordToken  {
	
	public StateDeclaration_SemicolonKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateDeclarationAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StateDeclaration_Group_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StateDeclaration_DomainAssignment_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule StateDeclaration ****************/


/************ begin Rule State ****************
 *
 * State:
 * 	name=ID;
 *
 **/

// name=ID
protected class State_NameAssignment extends AssignmentToken  {
	
	public State_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStateRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getStateAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getStateAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule State ****************/


/************ begin Rule AbstractTypeRef ****************
 *
 * AbstractTypeRef:
 * 	DomainRef | AbstractDomain;
 *
 **/

// DomainRef | AbstractDomain
protected class AbstractTypeRef_Alternatives extends AlternativesToken {

	public AbstractTypeRef_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTypeRefAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractTypeRef_DomainRefParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractTypeRef_AbstractDomainParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainRefRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEnumerationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPrimitiveTypeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRangeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// DomainRef
protected class AbstractTypeRef_DomainRefParserRuleCall_0 extends RuleCallToken {
	
	public AbstractTypeRef_DomainRefParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTypeRefAccess().getDomainRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DomainRef_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(DomainRef_ReferenceAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// AbstractDomain
protected class AbstractTypeRef_AbstractDomainParserRuleCall_1 extends RuleCallToken {
	
	public AbstractTypeRef_AbstractDomainParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTypeRefAccess().getAbstractDomainParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractDomain_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumerationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPrimitiveTypeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRangeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(AbstractDomain_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractTypeRef ****************/


/************ begin Rule DomainRef ****************
 *
 * DomainRef:
 * 	reference=[Domain];
 *
 **/

// reference=[Domain]
protected class DomainRef_ReferenceAssignment extends AssignmentToken  {
	
	public DomainRef_ReferenceAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDomainRefAccess().getReferenceAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDomainRefRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("reference",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("reference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDomainRefAccess().getReferenceDomainCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getDomainRefAccess().getReferenceDomainCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule DomainRef ****************/


/************ begin Rule NodeInstanceSpecification ****************
 *
 * NodeInstanceSpecification:
 * 	"sub" ownedNodeInstanceDeclarations+=NodeInstanceDeclaration*;
 *
 **/

// "sub" ownedNodeInstanceDeclarations+=NodeInstanceDeclaration*
protected class NodeInstanceSpecification_Group extends GroupToken {
	
	public NodeInstanceSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeInstanceSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceSpecification_OwnedNodeInstanceDeclarationsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NodeInstanceSpecification_SubKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeInstanceSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "sub"
protected class NodeInstanceSpecification_SubKeyword_0 extends KeywordToken  {
	
	public NodeInstanceSpecification_SubKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeInstanceSpecificationAccess().getSubKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedNodeInstanceDeclarations+=NodeInstanceDeclaration*
protected class NodeInstanceSpecification_OwnedNodeInstanceDeclarationsAssignment_1 extends AssignmentToken  {
	
	public NodeInstanceSpecification_OwnedNodeInstanceDeclarationsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeInstanceSpecificationAccess().getOwnedNodeInstanceDeclarationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedNodeInstanceDeclarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedNodeInstanceDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeInstanceDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNodeInstanceSpecificationAccess().getOwnedNodeInstanceDeclarationsNodeInstanceDeclarationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NodeInstanceSpecification_OwnedNodeInstanceDeclarationsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new NodeInstanceSpecification_SubKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NodeInstanceSpecification ****************/


/************ begin Rule NodeInstanceDeclaration ****************
 *
 * NodeInstanceDeclaration:
 * 	ownedNodeInstances+=NodeInstance ("," ownedNodeInstances+=NodeInstance)* ":" nodeType=[Node] ";";
 *
 **/

// ownedNodeInstances+=NodeInstance ("," ownedNodeInstances+=NodeInstance)* ":" nodeType=[Node] ";"
protected class NodeInstanceDeclaration_Group extends GroupToken {
	
	public NodeInstanceDeclaration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_SemicolonKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeInstanceDeclarationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedNodeInstances+=NodeInstance
protected class NodeInstanceDeclaration_OwnedNodeInstancesAssignment_0 extends AssignmentToken  {
	
	public NodeInstanceDeclaration_OwnedNodeInstancesAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getOwnedNodeInstancesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstance_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedNodeInstances",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedNodeInstances");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeInstanceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNodeInstanceDeclarationAccess().getOwnedNodeInstancesNodeInstanceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("," ownedNodeInstances+=NodeInstance)*
protected class NodeInstanceDeclaration_Group_1 extends GroupToken {
	
	public NodeInstanceDeclaration_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_OwnedNodeInstancesAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class NodeInstanceDeclaration_CommaKeyword_1_0 extends KeywordToken  {
	
	public NodeInstanceDeclaration_CommaKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NodeInstanceDeclaration_OwnedNodeInstancesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedNodeInstances+=NodeInstance
protected class NodeInstanceDeclaration_OwnedNodeInstancesAssignment_1_1 extends AssignmentToken  {
	
	public NodeInstanceDeclaration_OwnedNodeInstancesAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getOwnedNodeInstancesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstance_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedNodeInstances",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedNodeInstances");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeInstanceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNodeInstanceDeclarationAccess().getOwnedNodeInstancesNodeInstanceParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NodeInstanceDeclaration_CommaKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":"
protected class NodeInstanceDeclaration_ColonKeyword_2 extends KeywordToken  {
	
	public NodeInstanceDeclaration_ColonKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NodeInstanceDeclaration_OwnedNodeInstancesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// nodeType=[Node]
protected class NodeInstanceDeclaration_NodeTypeAssignment_3 extends AssignmentToken  {
	
	public NodeInstanceDeclaration_NodeTypeAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getNodeTypeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_ColonKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nodeType",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nodeType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeInstanceDeclarationAccess().getNodeTypeNodeCrossReference_3_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getNodeInstanceDeclarationAccess().getNodeTypeNodeCrossReference_3_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ";"
protected class NodeInstanceDeclaration_SemicolonKeyword_4 extends KeywordToken  {
	
	public NodeInstanceDeclaration_SemicolonKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeInstanceDeclarationAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstanceDeclaration_NodeTypeAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule NodeInstanceDeclaration ****************/


/************ begin Rule NodeInstance ****************
 *
 * NodeInstance:
 * 	name=ID;
 *
 **/

// name=ID
protected class NodeInstance_NameAssignment extends AssignmentToken  {
	
	public NodeInstance_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeInstanceAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeInstanceRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getNodeInstanceAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getNodeInstanceAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule NodeInstance ****************/


/************ begin Rule AssertSpecification ****************
 *
 * AssertSpecification:
 * 	"assert" ownedAsserts+=Assert*;
 *
 **/

// "assert" ownedAsserts+=Assert*
protected class AssertSpecification_Group extends GroupToken {
	
	public AssertSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssertSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AssertSpecification_OwnedAssertsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AssertSpecification_AssertKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssertSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "assert"
protected class AssertSpecification_AssertKeyword_0 extends KeywordToken  {
	
	public AssertSpecification_AssertKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssertSpecificationAccess().getAssertKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedAsserts+=Assert*
protected class AssertSpecification_OwnedAssertsAssignment_1 extends AssignmentToken  {
	
	public AssertSpecification_OwnedAssertsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssertSpecificationAccess().getOwnedAssertsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assert_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedAsserts",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedAsserts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssertRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAssertSpecificationAccess().getOwnedAssertsAssertParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AssertSpecification_OwnedAssertsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new AssertSpecification_AssertKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule AssertSpecification ****************/


/************ begin Rule Assert ****************
 *
 * Assert:
 * 	ownedExpressions+=AbstractBooleanExpression ";";
 *
 **/

// ownedExpressions+=AbstractBooleanExpression ";"
protected class Assert_Group extends GroupToken {
	
	public Assert_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssertAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assert_SemicolonKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssertRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedExpressions+=AbstractBooleanExpression
protected class Assert_OwnedExpressionsAssignment_0 extends AssignmentToken  {
	
	public Assert_OwnedExpressionsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssertAccess().getOwnedExpressionsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractBooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAssertAccess().getOwnedExpressionsAbstractBooleanExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ";"
protected class Assert_SemicolonKeyword_1 extends KeywordToken  {
	
	public Assert_SemicolonKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssertAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assert_OwnedExpressionsAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule Assert ****************/


/************ begin Rule VectorSpecification ****************
 *
 * VectorSpecification:
 * 	"sync" ownedVectors+=Vector*;
 *
 **/

// "sync" ownedVectors+=Vector*
protected class VectorSpecification_Group extends GroupToken {
	
	public VectorSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorSpecification_OwnedVectorsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new VectorSpecification_SyncKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVectorSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "sync"
protected class VectorSpecification_SyncKeyword_0 extends KeywordToken  {
	
	public VectorSpecification_SyncKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorSpecificationAccess().getSyncKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedVectors+=Vector*
protected class VectorSpecification_OwnedVectorsAssignment_1 extends AssignmentToken  {
	
	public VectorSpecification_OwnedVectorsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorSpecificationAccess().getOwnedVectorsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedVectors",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedVectors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVectorRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVectorSpecificationAccess().getOwnedVectorsVectorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VectorSpecification_OwnedVectorsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new VectorSpecification_SyncKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VectorSpecification ****************/


/************ begin Rule Vector ****************
 *
 * Vector:
 * 	"<" ownedParameters+=VectorParameter ("," ownedParameters+=VectorParameter)* ">" ("[" cardinality=Cardinality "]")?
 * 	";";
 *
 **/

// "<" ownedParameters+=VectorParameter ("," ownedParameters+=VectorParameter)* ">" ("[" cardinality=Cardinality "]")? ";"
protected class Vector_Group extends GroupToken {
	
	public Vector_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_SemicolonKeyword_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVectorRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "<"
protected class Vector_LessThanSignKeyword_0 extends KeywordToken  {
	
	public Vector_LessThanSignKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getLessThanSignKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedParameters+=VectorParameter
protected class Vector_OwnedParametersAssignment_1 extends AssignmentToken  {
	
	public Vector_OwnedParametersAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorAccess().getOwnedParametersAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedParameters",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVectorParameterRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVectorAccess().getOwnedParametersVectorParameterParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Vector_LessThanSignKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," ownedParameters+=VectorParameter)*
protected class Vector_Group_2 extends GroupToken {
	
	public Vector_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_OwnedParametersAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class Vector_CommaKeyword_2_0 extends KeywordToken  {
	
	public Vector_CommaKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Vector_OwnedParametersAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedParameters+=VectorParameter
protected class Vector_OwnedParametersAssignment_2_1 extends AssignmentToken  {
	
	public Vector_OwnedParametersAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorAccess().getOwnedParametersAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedParameters",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVectorParameterRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVectorAccess().getOwnedParametersVectorParameterParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Vector_CommaKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class Vector_GreaterThanSignKeyword_3 extends KeywordToken  {
	
	public Vector_GreaterThanSignKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getGreaterThanSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Vector_OwnedParametersAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ("[" cardinality=Cardinality "]")?
protected class Vector_Group_4 extends GroupToken {
	
	public Vector_Group_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_RightSquareBracketKeyword_4_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "["
protected class Vector_LeftSquareBracketKeyword_4_0 extends KeywordToken  {
	
	public Vector_LeftSquareBracketKeyword_4_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getLeftSquareBracketKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_GreaterThanSignKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// cardinality=Cardinality
protected class Vector_CardinalityAssignment_4_1 extends AssignmentToken  {
	
	public Vector_CardinalityAssignment_4_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorAccess().getCardinalityAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Cardinality_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("cardinality",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("cardinality");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCardinalityRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVectorAccess().getCardinalityCardinalityParserRuleCall_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Vector_LeftSquareBracketKeyword_4_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class Vector_RightSquareBracketKeyword_4_2 extends KeywordToken  {
	
	public Vector_RightSquareBracketKeyword_4_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getRightSquareBracketKeyword_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_CardinalityAssignment_4_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// ";"
protected class Vector_SemicolonKeyword_5 extends KeywordToken  {
	
	public Vector_SemicolonKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vector_Group_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Vector_GreaterThanSignKeyword_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule Vector ****************/


/************ begin Rule VectorParameter ****************
 *
 * VectorParameter:
 * 	eventParameter=EventRef isRequired?="?"?;
 *
 **/

// eventParameter=EventRef isRequired?="?"?
protected class VectorParameter_Group extends GroupToken {
	
	public VectorParameter_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorParameter_IsRequiredAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new VectorParameter_EventParameterAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVectorParameterRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// eventParameter=EventRef
protected class VectorParameter_EventParameterAssignment_0 extends AssignmentToken  {
	
	public VectorParameter_EventParameterAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorParameterAccess().getEventParameterAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("eventParameter",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("eventParameter");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRefRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVectorParameterAccess().getEventParameterEventRefParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// isRequired?="?"?
protected class VectorParameter_IsRequiredAssignment_1 extends AssignmentToken  {
	
	public VectorParameter_IsRequiredAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorParameterAccess().getIsRequiredAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VectorParameter_EventParameterAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("isRequired",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("isRequired");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getVectorParameterAccess().getIsRequiredQuestionMarkKeyword_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule VectorParameter ****************/


/************ begin Rule Cardinality ****************
 *
 * Cardinality:
 * 	">" expression=AbstractExpression | ">=" expression=AbstractExpression | "=" expression=AbstractExpression;
 *
 **/

// ">" expression=AbstractExpression | ">=" expression=AbstractExpression | "=" expression=AbstractExpression
protected class Cardinality_Alternatives extends AlternativesToken {

	public Cardinality_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Cardinality_Group_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Cardinality_Group_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Cardinality_Group_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCardinalityRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ">" expression=AbstractExpression
protected class Cardinality_Group_0 extends GroupToken {
	
	public Cardinality_Group_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Cardinality_ExpressionAssignment_0_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ">"
protected class Cardinality_GreaterThanSignKeyword_0_0 extends KeywordToken  {
	
	public Cardinality_GreaterThanSignKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getGreaterThanSignKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// expression=AbstractExpression
protected class Cardinality_ExpressionAssignment_0_1 extends AssignmentToken  {
	
	public Cardinality_ExpressionAssignment_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getExpressionAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCardinalityAccess().getExpressionAbstractExpressionParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Cardinality_GreaterThanSignKeyword_0_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">=" expression=AbstractExpression
protected class Cardinality_Group_1 extends GroupToken {
	
	public Cardinality_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Cardinality_ExpressionAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ">="
protected class Cardinality_GreaterThanSignEqualsSignKeyword_1_0 extends KeywordToken  {
	
	public Cardinality_GreaterThanSignEqualsSignKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getGreaterThanSignEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// expression=AbstractExpression
protected class Cardinality_ExpressionAssignment_1_1 extends AssignmentToken  {
	
	public Cardinality_ExpressionAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getExpressionAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCardinalityAccess().getExpressionAbstractExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Cardinality_GreaterThanSignEqualsSignKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "=" expression=AbstractExpression
protected class Cardinality_Group_2 extends GroupToken {
	
	public Cardinality_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Cardinality_ExpressionAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "="
protected class Cardinality_EqualsSignKeyword_2_0 extends KeywordToken  {
	
	public Cardinality_EqualsSignKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getEqualsSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// expression=AbstractExpression
protected class Cardinality_ExpressionAssignment_2_1 extends AssignmentToken  {
	
	public Cardinality_ExpressionAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCardinalityAccess().getExpressionAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCardinalityAccess().getExpressionAbstractExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Cardinality_EqualsSignKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Cardinality ****************/


/************ begin Rule TransitionSpecification ****************
 *
 * TransitionSpecification:
 * 	"trans" ownedTransitionTransitions+=Transition*;
 *
 **/

// "trans" ownedTransitionTransitions+=Transition*
protected class TransitionSpecification_Group extends GroupToken {
	
	public TransitionSpecification_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTransitionSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TransitionSpecification_OwnedTransitionTransitionsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TransitionSpecification_TransKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getTransitionSpecificationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "trans"
protected class TransitionSpecification_TransKeyword_0 extends KeywordToken  {
	
	public TransitionSpecification_TransKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionSpecificationAccess().getTransKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedTransitionTransitions+=Transition*
protected class TransitionSpecification_OwnedTransitionTransitionsAssignment_1 extends AssignmentToken  {
	
	public TransitionSpecification_OwnedTransitionTransitionsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionSpecificationAccess().getOwnedTransitionTransitionsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedTransitionTransitions",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedTransitionTransitions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTransitionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTransitionSpecificationAccess().getOwnedTransitionTransitionsTransitionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TransitionSpecification_OwnedTransitionTransitionsAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new TransitionSpecification_TransKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TransitionSpecification ****************/


/************ begin Rule Transition ****************
 *
 * Transition:
 * 	ownedExpresion=AbstractExpression "|-" event=[Event] "->" (ownedAffectations+=Affectation (","
 * 	ownedAffectations+=Affectation)*)* ";";
 *
 **/

// ownedExpresion=AbstractExpression "|-" event=[Event] "->" (ownedAffectations+=Affectation (","
// ownedAffectations+=Affectation)*)* ";"
protected class Transition_Group extends GroupToken {
	
	public Transition_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTransitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_SemicolonKeyword_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getTransitionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ownedExpresion=AbstractExpression
protected class Transition_OwnedExpresionAssignment_0 extends AssignmentToken  {
	
	public Transition_OwnedExpresionAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getOwnedExpresionAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpresion",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpresion");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTransitionAccess().getOwnedExpresionAbstractExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// "|-"
protected class Transition_VerticalLineHyphenMinusKeyword_1 extends KeywordToken  {
	
	public Transition_VerticalLineHyphenMinusKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionAccess().getVerticalLineHyphenMinusKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_OwnedExpresionAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// event=[Event]
protected class Transition_EventAssignment_2 extends AssignmentToken  {
	
	public Transition_EventAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getEventAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_VerticalLineHyphenMinusKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("event",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("event");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTransitionAccess().getEventEventCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getTransitionAccess().getEventEventCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "->"
protected class Transition_HyphenMinusGreaterThanSignKeyword_3 extends KeywordToken  {
	
	public Transition_HyphenMinusGreaterThanSignKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionAccess().getHyphenMinusGreaterThanSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_EventAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// (ownedAffectations+=Affectation ("," ownedAffectations+=Affectation)*)*
protected class Transition_Group_4 extends GroupToken {
	
	public Transition_Group_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTransitionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_Group_4_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Transition_OwnedAffectationsAssignment_4_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedAffectations+=Affectation
protected class Transition_OwnedAffectationsAssignment_4_0 extends AssignmentToken  {
	
	public Transition_OwnedAffectationsAssignment_4_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getOwnedAffectationsAssignment_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Affectation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedAffectations",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedAffectations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAffectationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTransitionAccess().getOwnedAffectationsAffectationParserRuleCall_4_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Transition_Group_4(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Transition_HyphenMinusGreaterThanSignKeyword_3(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," ownedAffectations+=Affectation)*
protected class Transition_Group_4_1 extends GroupToken {
	
	public Transition_Group_4_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTransitionAccess().getGroup_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_OwnedAffectationsAssignment_4_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class Transition_CommaKeyword_4_1_0 extends KeywordToken  {
	
	public Transition_CommaKeyword_4_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionAccess().getCommaKeyword_4_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_Group_4_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Transition_OwnedAffectationsAssignment_4_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ownedAffectations+=Affectation
protected class Transition_OwnedAffectationsAssignment_4_1_1 extends AssignmentToken  {
	
	public Transition_OwnedAffectationsAssignment_4_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getOwnedAffectationsAssignment_4_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Affectation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedAffectations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedAffectations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAffectationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTransitionAccess().getOwnedAffectationsAffectationParserRuleCall_4_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Transition_CommaKeyword_4_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ";"
protected class Transition_SemicolonKeyword_5 extends KeywordToken  {
	
	public Transition_SemicolonKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Transition_Group_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Transition_HyphenMinusGreaterThanSignKeyword_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule Transition ****************/


/************ begin Rule Affectation ****************
 *
 * Affectation:
 * 	state=[State] ":=" ownedExpression=AbstractExpression;
 *
 **/

// state=[State] ":=" ownedExpression=AbstractExpression
protected class Affectation_Group extends GroupToken {
	
	public Affectation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAffectationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Affectation_OwnedExpressionAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAffectationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// state=[State]
protected class Affectation_StateAssignment_0 extends AssignmentToken  {
	
	public Affectation_StateAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAffectationAccess().getStateAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("state",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("state");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAffectationAccess().getStateStateCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getAffectationAccess().getStateStateCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":="
protected class Affectation_ColonEqualsSignKeyword_1 extends KeywordToken  {
	
	public Affectation_ColonEqualsSignKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAffectationAccess().getColonEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Affectation_StateAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ownedExpression=AbstractExpression
protected class Affectation_OwnedExpressionAssignment_2 extends AssignmentToken  {
	
	public Affectation_OwnedExpressionAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAffectationAccess().getOwnedExpressionAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedExpression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAffectationAccess().getOwnedExpressionAbstractExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Affectation_ColonEqualsSignKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Affectation ****************/


/************ begin Rule AbstractExpression ****************
 *
 * AbstractExpression:
 * 	IfThenElse | Switch | Expression;
 *
 **/

// IfThenElse | Switch | Expression
protected class AbstractExpression_Alternatives extends AlternativesToken {

	public AbstractExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractExpression_IfThenElseParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractExpression_SwitchParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AbstractExpression_ExpressionParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIfThenElseRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSwitchRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// IfThenElse
protected class AbstractExpression_IfThenElseParserRuleCall_0 extends RuleCallToken {
	
	public AbstractExpression_IfThenElseParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractExpressionAccess().getIfThenElseParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IfThenElse_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIfThenElseRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IfThenElse_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Switch
protected class AbstractExpression_SwitchParserRuleCall_1 extends RuleCallToken {
	
	public AbstractExpression_SwitchParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractExpressionAccess().getSwitchParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSwitchRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Switch_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Expression
protected class AbstractExpression_ExpressionParserRuleCall_2 extends RuleCallToken {
	
	public AbstractExpression_ExpressionParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractExpressionAccess().getExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Expression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractExpression ****************/


/************ begin Rule AbstractBooleanExpression ****************
 *
 * AbstractBooleanExpression:
 * 	IfThenElse | Switch | BooleanExpression;
 *
 **/

// IfThenElse | Switch | BooleanExpression
protected class AbstractBooleanExpression_Alternatives extends AlternativesToken {

	public AbstractBooleanExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractBooleanExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AbstractBooleanExpression_IfThenElseParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AbstractBooleanExpression_SwitchParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AbstractBooleanExpression_BooleanExpressionParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIfThenElseRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSwitchRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// IfThenElse
protected class AbstractBooleanExpression_IfThenElseParserRuleCall_0 extends RuleCallToken {
	
	public AbstractBooleanExpression_IfThenElseParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractBooleanExpressionAccess().getIfThenElseParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IfThenElse_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIfThenElseRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IfThenElse_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Switch
protected class AbstractBooleanExpression_SwitchParserRuleCall_1 extends RuleCallToken {
	
	public AbstractBooleanExpression_SwitchParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractBooleanExpressionAccess().getSwitchParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSwitchRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Switch_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// BooleanExpression
protected class AbstractBooleanExpression_BooleanExpressionParserRuleCall_2 extends RuleCallToken {
	
	public AbstractBooleanExpression_BooleanExpressionParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractBooleanExpressionAccess().getBooleanExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_AndParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanExpression_AndParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractBooleanExpression ****************/


/************ begin Rule Switch ****************
 *
 * Switch:
 * 	"case {" ownedCases+=CaseExpression* "else" default=Expression "}";
 *
 **/

// "case {" ownedCases+=CaseExpression* "else" default=Expression "}"
protected class Switch_Group extends GroupToken {
	
	public Switch_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_RightCurlyBracketKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSwitchRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "case {"
protected class Switch_CaseKeyword_0 extends KeywordToken  {
	
	public Switch_CaseKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchAccess().getCaseKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ownedCases+=CaseExpression*
protected class Switch_OwnedCasesAssignment_1 extends AssignmentToken  {
	
	public Switch_OwnedCasesAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchAccess().getOwnedCasesAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CaseExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ownedCases",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ownedCases");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCaseExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSwitchAccess().getOwnedCasesCaseExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Switch_OwnedCasesAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Switch_CaseKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "else"
protected class Switch_ElseKeyword_2 extends KeywordToken  {
	
	public Switch_ElseKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchAccess().getElseKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_OwnedCasesAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Switch_CaseKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// default=Expression
protected class Switch_DefaultAssignment_3 extends AssignmentToken  {
	
	public Switch_DefaultAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchAccess().getDefaultAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("default",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("default");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSwitchAccess().getDefaultExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Switch_ElseKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Switch_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public Switch_RightCurlyBracketKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_DefaultAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule Switch ****************/


/************ begin Rule CaseExpression ****************
 *
 * CaseExpression:
 * 	condition=BooleanExpression ":" body=Expression ",";
 *
 **/

// condition=BooleanExpression ":" body=Expression ","
protected class CaseExpression_Group extends GroupToken {
	
	public CaseExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CaseExpression_CommaKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCaseExpressionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// condition=BooleanExpression
protected class CaseExpression_ConditionAssignment_0 extends AssignmentToken  {
	
	public CaseExpression_ConditionAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getConditionAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_AndParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("condition",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("condition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCaseExpressionAccess().getConditionBooleanExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ":"
protected class CaseExpression_ColonKeyword_1 extends KeywordToken  {
	
	public CaseExpression_ColonKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CaseExpression_ConditionAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// body=Expression
protected class CaseExpression_BodyAssignment_2 extends AssignmentToken  {
	
	public CaseExpression_BodyAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getBodyAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("body",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCaseExpressionAccess().getBodyExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_ColonKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ","
protected class CaseExpression_CommaKeyword_3 extends KeywordToken  {
	
	public CaseExpression_CommaKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getCommaKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CaseExpression_BodyAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule CaseExpression ****************/


/************ begin Rule IfThenElse ****************
 *
 * IfThenElse:
 * 	"if" condition=BooleanExpression "then" then=(Switch | Expression) "else" else=(Switch | Expression);
 *
 **/

// "if" condition=BooleanExpression "then" then=(Switch | Expression) "else" else=(Switch | Expression)
protected class IfThenElse_Group extends GroupToken {
	
	public IfThenElse_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IfThenElse_ElseAssignment_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIfThenElseRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "if"
protected class IfThenElse_IfKeyword_0 extends KeywordToken  {
	
	public IfThenElse_IfKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getIfKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// condition=BooleanExpression
protected class IfThenElse_ConditionAssignment_1 extends AssignmentToken  {
	
	public IfThenElse_ConditionAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getConditionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_AndParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("condition",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("condition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getIfThenElseAccess().getConditionBooleanExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfThenElse_IfKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "then"
protected class IfThenElse_ThenKeyword_2 extends KeywordToken  {
	
	public IfThenElse_ThenKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getThenKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IfThenElse_ConditionAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// then=(Switch | Expression)
protected class IfThenElse_ThenAssignment_3 extends AssignmentToken  {
	
	public IfThenElse_ThenAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getThenAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_Group(this, this, 0, inst);
			case 1: return new Expression_Group(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("then",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("then");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSwitchRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getIfThenElseAccess().getThenSwitchParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getIfThenElseAccess().getThenExpressionParserRuleCall_3_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfThenElse_ThenKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "else"
protected class IfThenElse_ElseKeyword_4 extends KeywordToken  {
	
	public IfThenElse_ElseKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getElseKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IfThenElse_ThenAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// else=(Switch | Expression)
protected class IfThenElse_ElseAssignment_5 extends AssignmentToken  {
	
	public IfThenElse_ElseAssignment_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfThenElseAccess().getElseAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Switch_Group(this, this, 0, inst);
			case 1: return new Expression_Group(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("else",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("else");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSwitchRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getIfThenElseAccess().getElseSwitchParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getIfThenElseAccess().getElseExpressionParserRuleCall_5_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfThenElse_ElseKeyword_4(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule IfThenElse ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 * 	Minus ({Addition.leftOperand=current} "+" rightOperand=Minus)*;
 *
 **/

// Minus ({Addition.leftOperand=current} "+" rightOperand=Minus)*
protected class Expression_Group extends GroupToken {
	
	public Expression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Expression_MinusParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Minus
protected class Expression_MinusParserRuleCall_0 extends RuleCallToken {
	
	public Expression_MinusParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getMinusParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Minus_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Addition.leftOperand=current} "+" rightOperand=Minus)*
protected class Expression_Group_1 extends GroupToken {
	
	public Expression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Addition.leftOperand=current}
protected class Expression_AdditionLeftOperandAction_1_0 extends ActionToken  {

	public Expression_AdditionLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Expression_MinusParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "+"
protected class Expression_PlusSignKeyword_1_1 extends KeywordToken  {
	
	public Expression_PlusSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getPlusSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_AdditionLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Minus
protected class Expression_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Expression_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMinusRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getExpressionAccess().getRightOperandMinusParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Expression_PlusSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Expression ****************/


/************ begin Rule Minus ****************
 *
 * Minus returns Expression:
 * 	Multiplication ({Minus.leftOperand=current} "-" rightOperand=Multiplication)*;
 *
 **/

// Multiplication ({Minus.leftOperand=current} "-" rightOperand=Multiplication)*
protected class Minus_Group extends GroupToken {
	
	public Minus_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMinusAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Minus_MultiplicationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Multiplication
protected class Minus_MultiplicationParserRuleCall_0 extends RuleCallToken {
	
	public Minus_MultiplicationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMinusAccess().getMultiplicationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Multiplication_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Minus.leftOperand=current} "-" rightOperand=Multiplication)*
protected class Minus_Group_1 extends GroupToken {
	
	public Minus_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMinusAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Minus.leftOperand=current}
protected class Minus_MinusLeftOperandAction_1_0 extends ActionToken  {

	public Minus_MinusLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Minus_MultiplicationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "-"
protected class Minus_HyphenMinusKeyword_1_1 extends KeywordToken  {
	
	public Minus_HyphenMinusKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMinusAccess().getHyphenMinusKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Minus_MinusLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Multiplication
protected class Minus_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Minus_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMinusAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMinusAccess().getRightOperandMultiplicationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Minus_HyphenMinusKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Minus ****************/


/************ begin Rule Multiplication ****************
 *
 * Multiplication returns Expression:
 * 	Division ({Multiplication.leftOperand=current} "*" rightOperand=Division)*;
 *
 **/

// Division ({Multiplication.leftOperand=current} "*" rightOperand=Division)*
protected class Multiplication_Group extends GroupToken {
	
	public Multiplication_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Multiplication_DivisionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Division
protected class Multiplication_DivisionParserRuleCall_0 extends RuleCallToken {
	
	public Multiplication_DivisionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getDivisionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Division_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Multiplication.leftOperand=current} "*" rightOperand=Division)*
protected class Multiplication_Group_1 extends GroupToken {
	
	public Multiplication_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Multiplication.leftOperand=current}
protected class Multiplication_MultiplicationLeftOperandAction_1_0 extends ActionToken  {

	public Multiplication_MultiplicationLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Multiplication_DivisionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "*"
protected class Multiplication_AsteriskKeyword_1_1 extends KeywordToken  {
	
	public Multiplication_AsteriskKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getAsteriskKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Multiplication_MultiplicationLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Division
protected class Multiplication_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Multiplication_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDivisionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMultiplicationAccess().getRightOperandDivisionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Multiplication_AsteriskKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Multiplication ****************/


/************ begin Rule Division ****************
 *
 * Division returns Expression:
 * 	BooleanExpression ({Division.leftOperand=current} "/" rightOperand=BooleanExpression)*;
 *
 **/

// BooleanExpression ({Division.leftOperand=current} "/" rightOperand=BooleanExpression)*
protected class Division_Group extends GroupToken {
	
	public Division_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDivisionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Division_BooleanExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BooleanExpression
protected class Division_BooleanExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Division_BooleanExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDivisionAccess().getBooleanExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_AndParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(BooleanExpression_AndParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Division.leftOperand=current} "/" rightOperand=BooleanExpression)*
protected class Division_Group_1 extends GroupToken {
	
	public Division_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDivisionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Division.leftOperand=current}
protected class Division_DivisionLeftOperandAction_1_0 extends ActionToken  {

	public Division_DivisionLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Division_BooleanExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "/"
protected class Division_SolidusKeyword_1_1 extends KeywordToken  {
	
	public Division_SolidusKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDivisionAccess().getSolidusKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Division_DivisionLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=BooleanExpression
protected class Division_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Division_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDivisionAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_AndParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDivisionAccess().getRightOperandBooleanExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Division_SolidusKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Division ****************/


/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression returns Expression:
 * 	And;
 *
 **/

// And
protected class BooleanExpression_AndParserRuleCall extends RuleCallToken {
	
	public BooleanExpression_AndParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getAndParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(And_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule BooleanExpression ****************/


/************ begin Rule And ****************
 *
 * And returns Expression:
 * 	Or ({And.leftOperand=current} ("and" | "&") rightOperand=Or)*;
 *
 **/

// Or ({And.leftOperand=current} ("and" | "&") rightOperand=Or)*
protected class And_Group extends GroupToken {
	
	public And_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new And_OrParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Or
protected class And_OrParserRuleCall_0 extends RuleCallToken {
	
	public And_OrParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndAccess().getOrParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Or_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({And.leftOperand=current} ("and" | "&") rightOperand=Or)*
protected class And_Group_1 extends GroupToken {
	
	public And_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {And.leftOperand=current}
protected class And_AndLeftOperandAction_1_0 extends ActionToken  {

	public And_AndLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndAccess().getAndLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new And_OrParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "and" | "&"
protected class And_Alternatives_1_1 extends AlternativesToken {

	public And_Alternatives_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAndAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_AndKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "and"
protected class And_AndKeyword_1_1_0 extends KeywordToken  {
	
	public And_AndKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAndAccess().getAndKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new And_AndLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// rightOperand=Or
protected class And_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public And_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAndAccess().getRightOperandOrParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new And_Alternatives_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule And ****************/


/************ begin Rule Or ****************
 *
 * Or returns Expression:
 * 	Equal ({Or.leftOperand=current} ("or" | "|") rightOperand=Equal)*;
 *
 **/

// Equal ({Or.leftOperand=current} ("or" | "|") rightOperand=Equal)*
protected class Or_Group extends GroupToken {
	
	public Or_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Or_EqualParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Equal
protected class Or_EqualParserRuleCall_0 extends RuleCallToken {
	
	public Or_EqualParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrAccess().getEqualParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Equal_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Or.leftOperand=current} ("or" | "|") rightOperand=Equal)*
protected class Or_Group_1 extends GroupToken {
	
	public Or_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Or.leftOperand=current}
protected class Or_OrLeftOperandAction_1_0 extends ActionToken  {

	public Or_OrLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrAccess().getOrLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Or_EqualParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "or" | "|"
protected class Or_Alternatives_1_1 extends AlternativesToken {

	public Or_Alternatives_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getOrAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_OrKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "or"
protected class Or_OrKeyword_1_1_0 extends KeywordToken  {
	
	public Or_OrKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOrAccess().getOrKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Or_OrLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// rightOperand=Equal
protected class Or_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Or_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEqualRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getOrAccess().getRightOperandEqualParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Or_Alternatives_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Or ****************/


/************ begin Rule Equal ****************
 *
 * Equal returns Expression:
 * 	NotEqual ({Equal.leftOperand=current} "=" rightOperand=NotEqual)*;
 *
 **/

// NotEqual ({Equal.leftOperand=current} "=" rightOperand=NotEqual)*
protected class Equal_Group extends GroupToken {
	
	public Equal_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Equal_NotEqualParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// NotEqual
protected class Equal_NotEqualParserRuleCall_0 extends RuleCallToken {
	
	public Equal_NotEqualParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEqualAccess().getNotEqualParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(NotEqual_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Equal.leftOperand=current} "=" rightOperand=NotEqual)*
protected class Equal_Group_1 extends GroupToken {
	
	public Equal_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Equal.leftOperand=current}
protected class Equal_EqualLeftOperandAction_1_0 extends ActionToken  {

	public Equal_EqualLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Equal_NotEqualParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "="
protected class Equal_EqualsSignKeyword_1_1 extends KeywordToken  {
	
	public Equal_EqualsSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEqualAccess().getEqualsSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Equal_EqualLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=NotEqual
protected class Equal_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Equal_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotEqualRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEqualAccess().getRightOperandNotEqualParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Equal_EqualsSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Equal ****************/


/************ begin Rule NotEqual ****************
 *
 * NotEqual returns Expression:
 * 	StrictLower ({NotEqual.leftOperand=current} "!=" rightOperand=StrictLower)*;
 *
 **/

// StrictLower ({NotEqual.leftOperand=current} "!=" rightOperand=StrictLower)*
protected class NotEqual_Group extends GroupToken {
	
	public NotEqual_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NotEqual_StrictLowerParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// StrictLower
protected class NotEqual_StrictLowerParserRuleCall_0 extends RuleCallToken {
	
	public NotEqual_StrictLowerParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getStrictLowerParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(StrictLower_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({NotEqual.leftOperand=current} "!=" rightOperand=StrictLower)*
protected class NotEqual_Group_1 extends GroupToken {
	
	public NotEqual_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NotEqual.leftOperand=current}
protected class NotEqual_NotEqualLeftOperandAction_1_0 extends ActionToken  {

	public NotEqual_NotEqualLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NotEqual_StrictLowerParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "!="
protected class NotEqual_ExclamationMarkEqualsSignKeyword_1_1 extends KeywordToken  {
	
	public NotEqual_ExclamationMarkEqualsSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getExclamationMarkEqualsSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotEqual_NotEqualLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=StrictLower
protected class NotEqual_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public NotEqual_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNotEqualAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStrictLowerRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNotEqualAccess().getRightOperandStrictLowerParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotEqual_ExclamationMarkEqualsSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule NotEqual ****************/


/************ begin Rule StrictLower ****************
 *
 * StrictLower returns Expression:
 * 	Lower ({StrictLower.leftOperand=current} "<" rightOperand=Lower)*;
 *
 **/

// Lower ({StrictLower.leftOperand=current} "<" rightOperand=Lower)*
protected class StrictLower_Group extends GroupToken {
	
	public StrictLower_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StrictLower_LowerParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Lower
protected class StrictLower_LowerParserRuleCall_0 extends RuleCallToken {
	
	public StrictLower_LowerParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getLowerParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Lower_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({StrictLower.leftOperand=current} "<" rightOperand=Lower)*
protected class StrictLower_Group_1 extends GroupToken {
	
	public StrictLower_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {StrictLower.leftOperand=current}
protected class StrictLower_StrictLowerLeftOperandAction_1_0 extends ActionToken  {

	public StrictLower_StrictLowerLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StrictLower_LowerParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "<"
protected class StrictLower_LessThanSignKeyword_1_1 extends KeywordToken  {
	
	public StrictLower_LessThanSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getLessThanSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictLower_StrictLowerLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Lower
protected class StrictLower_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public StrictLower_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStrictLowerAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLowerRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStrictLowerAccess().getRightOperandLowerParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StrictLower_LessThanSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule StrictLower ****************/


/************ begin Rule Lower ****************
 *
 * Lower returns Expression:
 * 	StrictUpper ({Lower.leftOperand=current} "<=" rightOperand=StrictUpper)*;
 *
 **/

// StrictUpper ({Lower.leftOperand=current} "<=" rightOperand=StrictUpper)*
protected class Lower_Group extends GroupToken {
	
	public Lower_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLowerAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Lower_StrictUpperParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// StrictUpper
protected class Lower_StrictUpperParserRuleCall_0 extends RuleCallToken {
	
	public Lower_StrictUpperParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLowerAccess().getStrictUpperParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(StrictUpper_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Lower.leftOperand=current} "<=" rightOperand=StrictUpper)*
protected class Lower_Group_1 extends GroupToken {
	
	public Lower_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLowerAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Lower.leftOperand=current}
protected class Lower_LowerLeftOperandAction_1_0 extends ActionToken  {

	public Lower_LowerLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Lower_StrictUpperParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "<="
protected class Lower_LessThanSignEqualsSignKeyword_1_1 extends KeywordToken  {
	
	public Lower_LessThanSignEqualsSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLowerAccess().getLessThanSignEqualsSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lower_LowerLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=StrictUpper
protected class Lower_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Lower_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLowerAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStrictUpperRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getLowerAccess().getRightOperandStrictUpperParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Lower_LessThanSignEqualsSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Lower ****************/


/************ begin Rule StrictUpper ****************
 *
 * StrictUpper returns Expression:
 * 	Upper ({StrictUpper.leftOperand=current} ">" rightOperand=Upper)*;
 *
 **/

// Upper ({StrictUpper.leftOperand=current} ">" rightOperand=Upper)*
protected class StrictUpper_Group extends GroupToken {
	
	public StrictUpper_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StrictUpper_UpperParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Upper
protected class StrictUpper_UpperParserRuleCall_0 extends RuleCallToken {
	
	public StrictUpper_UpperParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getUpperParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Upper_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({StrictUpper.leftOperand=current} ">" rightOperand=Upper)*
protected class StrictUpper_Group_1 extends GroupToken {
	
	public StrictUpper_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {StrictUpper.leftOperand=current}
protected class StrictUpper_StrictUpperLeftOperandAction_1_0 extends ActionToken  {

	public StrictUpper_StrictUpperLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StrictUpper_UpperParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// ">"
protected class StrictUpper_GreaterThanSignKeyword_1_1 extends KeywordToken  {
	
	public StrictUpper_GreaterThanSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getGreaterThanSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StrictUpper_StrictUpperLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Upper
protected class StrictUpper_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public StrictUpper_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStrictUpperAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUpperRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStrictUpperAccess().getRightOperandUpperParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StrictUpper_GreaterThanSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule StrictUpper ****************/


/************ begin Rule Upper ****************
 *
 * Upper returns Expression:
 * 	Imply ({Upper.leftOperand=current} ">=" rightOperand=Imply)*;
 *
 **/

// Imply ({Upper.leftOperand=current} ">=" rightOperand=Imply)*
protected class Upper_Group extends GroupToken {
	
	public Upper_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUpperAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Upper_ImplyParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Imply
protected class Upper_ImplyParserRuleCall_0 extends RuleCallToken {
	
	public Upper_ImplyParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUpperAccess().getImplyParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Imply_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Upper.leftOperand=current} ">=" rightOperand=Imply)*
protected class Upper_Group_1 extends GroupToken {
	
	public Upper_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUpperAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Upper.leftOperand=current}
protected class Upper_UpperLeftOperandAction_1_0 extends ActionToken  {

	public Upper_UpperLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Upper_ImplyParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// ">="
protected class Upper_GreaterThanSignEqualsSignKeyword_1_1 extends KeywordToken  {
	
	public Upper_GreaterThanSignEqualsSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUpperAccess().getGreaterThanSignEqualsSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Upper_UpperLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Imply
protected class Upper_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Upper_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUpperAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImplyRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getUpperAccess().getRightOperandImplyParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Upper_GreaterThanSignEqualsSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Upper ****************/


/************ begin Rule Imply ****************
 *
 * Imply returns Expression:
 * 	Not ({Imply.leftOperand=current} "=>" rightOperand=Not)*;
 *
 **/

// Not ({Imply.leftOperand=current} "=>" rightOperand=Not)*
protected class Imply_Group extends GroupToken {
	
	public Imply_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImplyAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Imply_NotParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Not
protected class Imply_NotParserRuleCall_0 extends RuleCallToken {
	
	public Imply_NotParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getImplyAccess().getNotParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Not_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Not_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({Imply.leftOperand=current} "=>" rightOperand=Not)*
protected class Imply_Group_1 extends GroupToken {
	
	public Imply_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImplyAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_RightOperandAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {Imply.leftOperand=current}
protected class Imply_ImplyLeftOperandAction_1_0 extends ActionToken  {

	public Imply_ImplyLeftOperandAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Imply_NotParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("leftOperand", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("leftOperand")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "=>"
protected class Imply_EqualsSignGreaterThanSignKeyword_1_1 extends KeywordToken  {
	
	public Imply_EqualsSignGreaterThanSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImplyAccess().getEqualsSignGreaterThanSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Imply_ImplyLeftOperandAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rightOperand=Not
protected class Imply_RightOperandAssignment_1_2 extends AssignmentToken  {
	
	public Imply_RightOperandAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImplyAccess().getRightOperandAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Not_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rightOperand",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rightOperand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getImplyAccess().getRightOperandNotParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Imply_EqualsSignGreaterThanSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Imply ****************/


/************ begin Rule Not ****************
 *
 * Not returns Expression:
 * 	("~" | "not") operand=Atom | Atom;
 *
 **/

// ("~" | "not") operand=Atom | Atom
protected class Not_Alternatives extends AlternativesToken {

	public Not_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Not_Group_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Not_AtomParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ("~" | "not") operand=Atom
protected class Not_Group_0 extends GroupToken {
	
	public Not_Group_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNotAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Not_OperandAssignment_0_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "~" | "not"
protected class Not_Alternatives_0_0 extends AlternativesToken {

	public Not_Alternatives_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotAccess().getAlternatives_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Not_TildeKeyword_0_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "~"
protected class Not_TildeKeyword_0_0_0 extends KeywordToken  {
	
	public Not_TildeKeyword_0_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNotAccess().getTildeKeyword_0_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// operand=Atom
protected class Not_OperandAssignment_0_1 extends AssignmentToken  {
	
	public Not_OperandAssignment_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNotAccess().getOperandAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operand",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNotAccess().getOperandAtomParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Not_Alternatives_0_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// Atom
protected class Not_AtomParserRuleCall_1 extends RuleCallToken {
	
	public Not_AtomParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotAccess().getAtomParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Atom_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Not ****************/


/************ begin Rule Atom ****************
 *
 * Atom returns Expression:
 * 	BooleanLiteral | StringLiteral | IntegerLiteral | VariableRef | "(" Expression ")";
 *
 **/

// BooleanLiteral | StringLiteral | IntegerLiteral | VariableRef | "(" Expression ")"
protected class Atom_Alternatives extends AlternativesToken {

	public Atom_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAtomAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_BooleanLiteralParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Atom_StringLiteralParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Atom_IntegerLiteralParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new Atom_VariableRefParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new Atom_Group_4(lastRuleCallOrigin, this, 4, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExpressionAccess().getAdditionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getAndAccess().getAndLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getDivisionAccess().getDivisionLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEqualAccess().getEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getImplyAccess().getImplyLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLowerAccess().getLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMinusAccess().getMinusLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiplicationAccess().getMultiplicationLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotEqualAccess().getNotEqualLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrAccess().getOrLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictLowerAccess().getStrictLowerLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStrictUpperAccess().getStrictUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUpperAccess().getUpperLeftOperandAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BooleanLiteral
protected class Atom_BooleanLiteralParserRuleCall_0 extends RuleCallToken {
	
	public Atom_BooleanLiteralParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getBooleanLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanLiteral_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// StringLiteral
protected class Atom_StringLiteralParserRuleCall_1 extends RuleCallToken {
	
	public Atom_StringLiteralParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getStringLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StringLiteral_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// IntegerLiteral
protected class Atom_IntegerLiteralParserRuleCall_2 extends RuleCallToken {
	
	public Atom_IntegerLiteralParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getIntegerLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntegerLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IntegerLiteral_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// VariableRef
protected class Atom_VariableRefParserRuleCall_3 extends RuleCallToken {
	
	public Atom_VariableRefParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getVariableRefParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(VariableRef_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" Expression ")"
protected class Atom_Group_4 extends GroupToken {
	
	public Atom_Group_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAtomAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_RightParenthesisKeyword_4_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class Atom_LeftParenthesisKeyword_4_0 extends KeywordToken  {
	
	public Atom_LeftParenthesisKeyword_4_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getLeftParenthesisKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// Expression
protected class Atom_ExpressionParserRuleCall_4_1 extends RuleCallToken {
	
	public Atom_ExpressionParserRuleCall_4_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getExpressionParserRuleCall_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Expression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_LeftParenthesisKeyword_4_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class Atom_RightParenthesisKeyword_4_2 extends KeywordToken  {
	
	public Atom_RightParenthesisKeyword_4_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getRightParenthesisKeyword_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Atom_ExpressionParserRuleCall_4_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule Atom ****************/


/************ begin Rule EventRef ****************
 *
 * //('.' ownedFeature=QualifiedEventRef)?;
 * EventRef:
 * 	variable=[NavigableVariable] ({NestedQualifiedEventRef.target=current} "." nestedVariable=[NavigableVariable])*;
 *
 **/

// variable=[NavigableVariable] ({NestedQualifiedEventRef.target=current} "." nestedVariable=[NavigableVariable])*
protected class EventRef_Group extends GroupToken {
	
	public EventRef_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventRef_VariableAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventRefRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEventRefAccess().getNestedQualifiedEventRefTargetAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// variable=[NavigableVariable]
protected class EventRef_VariableAssignment_0 extends AssignmentToken  {
	
	public EventRef_VariableAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventRefAccess().getVariableAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventRefRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("variable",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRefAccess().getVariableNavigableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEventRefAccess().getVariableNavigableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ({NestedQualifiedEventRef.target=current} "." nestedVariable=[NavigableVariable])*
protected class EventRef_Group_1 extends GroupToken {
	
	public EventRef_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEventRefAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_NestedVariableAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventRefAccess().getNestedQualifiedEventRefTargetAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NestedQualifiedEventRef.target=current}
protected class EventRef_NestedQualifiedEventRefTargetAction_1_0 extends ActionToken  {

	public EventRef_NestedQualifiedEventRefTargetAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEventRefAccess().getNestedQualifiedEventRefTargetAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EventRef_VariableAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("target", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("target")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "."
protected class EventRef_FullStopKeyword_1_1 extends KeywordToken  {
	
	public EventRef_FullStopKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEventRefAccess().getFullStopKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_NestedQualifiedEventRefTargetAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// nestedVariable=[NavigableVariable]
protected class EventRef_NestedVariableAssignment_1_2 extends AssignmentToken  {
	
	public EventRef_NestedVariableAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEventRefAccess().getNestedVariableAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EventRef_FullStopKeyword_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nestedVariable",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nestedVariable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRefAccess().getNestedVariableNavigableVariableCrossReference_1_2_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEventRefAccess().getNestedVariableNavigableVariableCrossReference_1_2_0(); 
				return obj;
			}
		}
		return null;
	}

}



/************ end Rule EventRef ****************/


/************ begin Rule VariableRef ****************
 *
 * VariableRef:
 * 	variable=[NavigableVariable] ({NestedQualifiedVariableRef.target=current} "." nestedVariable=[NavigableVariable])*;
 *
 **/

// variable=[NavigableVariable] ({NestedQualifiedVariableRef.target=current} "." nestedVariable=[NavigableVariable])*
protected class VariableRef_Group extends GroupToken {
	
	public VariableRef_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new VariableRef_VariableAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// variable=[NavigableVariable]
protected class VariableRef_VariableAssignment_0 extends AssignmentToken  {
	
	public VariableRef_VariableAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getVariableAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableRefRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("variable",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRefAccess().getVariableNavigableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getVariableRefAccess().getVariableNavigableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ({NestedQualifiedVariableRef.target=current} "." nestedVariable=[NavigableVariable])*
protected class VariableRef_Group_1 extends GroupToken {
	
	public VariableRef_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_NestedVariableAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NestedQualifiedVariableRef.target=current}
protected class VariableRef_NestedQualifiedVariableRefTargetAction_1_0 extends ActionToken  {

	public VariableRef_NestedQualifiedVariableRefTargetAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getNestedQualifiedVariableRefTargetAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new VariableRef_VariableAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("target", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("target")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "."
protected class VariableRef_FullStopKeyword_1_1 extends KeywordToken  {
	
	public VariableRef_FullStopKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getFullStopKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_NestedQualifiedVariableRefTargetAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// nestedVariable=[NavigableVariable]
protected class VariableRef_NestedVariableAssignment_1_2 extends AssignmentToken  {
	
	public VariableRef_NestedVariableAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableRefAccess().getNestedVariableAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableRef_FullStopKeyword_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nestedVariable",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nestedVariable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRefAccess().getNestedVariableNavigableVariableCrossReference_1_2_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getVariableRefAccess().getNestedVariableNavigableVariableCrossReference_1_2_0(); 
				return obj;
			}
		}
		return null;
	}

}



/************ end Rule VariableRef ****************/


/************ begin Rule NavigableVariable ****************
 *
 * NavigableVariable:
 * 	NonNavigableVariable | NodeInstance | Event;
 *
 **/

// NonNavigableVariable | NodeInstance | Event
protected class NavigableVariable_Alternatives extends AlternativesToken {

	public NavigableVariable_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNavigableVariableAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NavigableVariable_NonNavigableVariableParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NavigableVariable_NodeInstanceParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new NavigableVariable_EventParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEventRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFlowRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNodeInstanceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStateRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// NonNavigableVariable
protected class NavigableVariable_NonNavigableVariableParserRuleCall_0 extends RuleCallToken {
	
	public NavigableVariable_NonNavigableVariableParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNavigableVariableAccess().getNonNavigableVariableParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NonNavigableVariable_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFlowRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStateRule().getType().getClassifier())
			return null;
		if(checkForRecursion(NonNavigableVariable_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// NodeInstance
protected class NavigableVariable_NodeInstanceParserRuleCall_1 extends RuleCallToken {
	
	public NavigableVariable_NodeInstanceParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNavigableVariableAccess().getNodeInstanceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NodeInstance_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNodeInstanceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(NodeInstance_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Event
protected class NavigableVariable_EventParserRuleCall_2 extends RuleCallToken {
	
	public NavigableVariable_EventParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNavigableVariableAccess().getEventParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Event_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEventRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Event_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NavigableVariable ****************/


/************ begin Rule NonNavigableVariable ****************
 *
 * NonNavigableVariable:
 * 	State | Literal | Constant | Flow;
 *
 **/

// State | Literal | Constant | Flow
protected class NonNavigableVariable_Alternatives extends AlternativesToken {

	public NonNavigableVariable_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNonNavigableVariableAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NonNavigableVariable_StateParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NonNavigableVariable_LiteralParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new NonNavigableVariable_ConstantParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new NonNavigableVariable_FlowParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFlowRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStateRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// State
protected class NonNavigableVariable_StateParserRuleCall_0 extends RuleCallToken {
	
	public NonNavigableVariable_StateParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNonNavigableVariableAccess().getStateParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new State_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStateRule().getType().getClassifier())
			return null;
		if(checkForRecursion(State_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Literal
protected class NonNavigableVariable_LiteralParserRuleCall_1 extends RuleCallToken {
	
	public NonNavigableVariable_LiteralParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNonNavigableVariableAccess().getLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Literal_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Literal_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Constant
protected class NonNavigableVariable_ConstantParserRuleCall_2 extends RuleCallToken {
	
	public NonNavigableVariable_ConstantParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNonNavigableVariableAccess().getConstantParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Constant_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConstantRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Constant_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Flow
protected class NonNavigableVariable_FlowParserRuleCall_3 extends RuleCallToken {
	
	public NonNavigableVariable_FlowParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNonNavigableVariableAccess().getFlowParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Flow_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFlowRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Flow_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NonNavigableVariable ****************/


/************ begin Rule BooleanLiteral ****************
 *
 * BooleanLiteral returns EBoolean:
 * 	value=("true" | "false");
 *
 **/

// value=("true" | "false")
protected class BooleanLiteral_ValueAssignment extends AssignmentToken  {
	
	public BooleanLiteral_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getBooleanLiteralAccess().getValueTrueKeyword_0_0(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getBooleanLiteralAccess().getValueTrueKeyword_0_0();
			return obj;
		}
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getBooleanLiteralAccess().getValueFalseKeyword_0_1(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getBooleanLiteralAccess().getValueFalseKeyword_0_1();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanLiteral ****************/


/************ begin Rule StringLiteral ****************
 *
 * StringLiteral returns EString:
 * 	value=STRING;
 *
 **/

// value=STRING
protected class StringLiteral_ValueAssignment extends AssignmentToken  {
	
	public StringLiteral_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLiteral ****************/


/************ begin Rule IntegerLiteral ****************
 *
 * IntegerLiteral returns EInteger:
 * 	value=INT;
 *
 **/

// value=INT
protected class IntegerLiteral_ValueAssignment extends AssignmentToken  {
	
	public IntegerLiteral_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntegerLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntegerLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntegerLiteral ****************/

}
